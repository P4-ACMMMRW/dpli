    /*
    virtual antlrcpp::Any visitChildren(tree::ParseTree *tree) override {
        AstNode* newNode = createNode(tree);
        AstNode* oldNode = new AstNode();

        int isTransferNode = tree->children.size() == 1;

        if (root == nullptr) {
            root = newNode; // Set root if this is the first node
            currentNode = newNode;
        }

        else if (!isTransferNode) {
            currentNode->children.push_back(newNode); 
            oldNode = currentNode;
            currentNode = newNode;
        }

        for (size_t i = 0; i < tree->children.size(); ++i) {
            if (tree->children[i]->children.size() == 0) {

                AstNode* leafNode = createLeafNode(tree, i);
                currentNode->children.push_back(leafNode);
            } 

            tree->children[i]->accept(this);
        }

        if (!isTransferNode) currentNode = oldNode;

        return nullptr;
    }

    AstNode* createNode(tree::ParseTree *tree) {
        ParserRuleContext* ctx = dynamic_cast<ParserRuleContext*>(tree);
        AstNode* newNode = new AstNode();
        newNode->text = tree->getText();
        newNode->rule = ctx->getRuleIndex();
        newNode->ruleName = parser->getRuleNames()[newNode->rule];
        return newNode;
    }

    AstNode* createLeafNode(tree::ParseTree *tree, size_t i) {
        AstNode* leafNode = new AstNode();
        leafNode->text = tree->children[i]->getText();
        leafNode->ruleName =  tree->children[i]->getText();
        return leafNode;
    }*/
